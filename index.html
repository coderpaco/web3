<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vpn.wtf</title>
	<link rel="icon" href="output2.ico" type="image/x-icon">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, globe;
        let mouseDown = false, previousMousePosition = { x: 0, y: 0 };
        let landTexture; // Variable to hold the land texture image
        const landColorRange = { min: [200, 200, 200], max: [255, 255, 255] }; // RGB range for land colors

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Create the globe
            const geometry = new THREE.SphereGeometry(50, 64, 64); // Increased segments for smoother surface
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('earth_texture.png', texture => { // Load local texture
                const material = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.FrontSide // Ensure only the front side is visible
                });

                globe = new THREE.Mesh(geometry, material);
                scene.add(globe);
                landTexture = texture.image; // Store the loaded texture image for analysis
            });

            camera.position.z = 100; // Ensure the camera is positioned correctly

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft white light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Bright light
            directionalLight.position.set(0, 1, 1).normalize();
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);

            setInterval(drawArc, 200);
            animate();
		    // Update renderer size and camera aspect on window resize
   	 	window.addEventListener('resize', onWindowResize);
    		onWindowResize(); // Call it initially to set the size correctly
        }

	function onWindowResize() {
	    const width = window.innerWidth;
	    const height = window.innerHeight;
	    camera.aspect = width / height;
	    camera.updateProjectionMatrix();
	    renderer.setSize(width, height);

   	 // Update camera position based on aspect ratio if needed
   	 camera.position.z = Math.max(100, height / 2);
	}
        function onMouseDown(event) {
            mouseDown = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (!mouseDown) return;

            const deltaMove = {
                x: event.clientX - previousMousePosition.x,
                y: event.clientY - previousMousePosition.y
            };

            globe.rotation.y += deltaMove.x * 0.005;  // Adjust rotation speed
            globe.rotation.x += deltaMove.y * 0.005;  // Adjust rotation speed

            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function isPointOnLand(lat, lon) {
            const x = Math.floor((lon + Math.PI) / (2 * Math.PI) * landTexture.width);
            const y = Math.floor((Math.PI / 2 - lat) / Math.PI * landTexture.height);

            const ctx = document.createElement('canvas').getContext('2d');
            ctx.drawImage(landTexture, 0, 0);
            
            const pixel = ctx.getImageData(x, y, 1, 1).data; // Get pixel data

            return (
                pixel[0] >= landColorRange.min[0] && pixel[0] <= landColorRange.max[0] &&
                pixel[1] >= landColorRange.min[1] && pixel[1] <= landColorRange.max[1] &&
                pixel[2] >= landColorRange.min[2] && pixel[2] <= landColorRange.max[2]
            );
        }


    const landPoints = [
    { lat: 0.7102, lon: -1.2915 }, // North America
    { lat: -0.4102, lon: -0.8149 }, // South America
    { lat: 0.8989, lon: -0.0022 }, // Europe
    { lat: -0.0225, lon: 0.6422 }, // Africa
    { lat: 0.6965, lon: 2.0340 }, // Asia
    { lat: -0.5910, lon: 2.6391 }, // Australia
    { lat: -1.5708, lon: 0.0000 }, // Antarctica
];


function drawArc() {
    const radius = 50;
    const heightOffset = 5; // Height offset for the arc

    // Randomly select two different land points from the array
    const pointAIndex = Math.floor(Math.random() * landPoints.length);
    const pointBIndex = Math.floor(Math.random() * landPoints.length);
    
    // Ensure A and B are different points
    if (pointAIndex === pointBIndex) return;

    const pointA = landPoints[pointAIndex];
    const pointB = landPoints[pointBIndex];

    // Calculate Cartesian coordinates for both points
    const pointACartesian = new THREE.Vector3(
        radius * Math.cos(pointA.lat) * Math.cos(pointA.lon),
        radius * Math.sin(pointA.lat),
        radius * Math.cos(pointA.lat) * Math.sin(pointA.lon)
    );
    const pointBCartesian = new THREE.Vector3(
        radius * Math.cos(pointB.lat) * Math.cos(pointB.lon),
        radius * Math.sin(pointB.lat),
        radius * Math.cos(pointB.lat) * Math.sin(pointB.lon)
    );

    // Create geometry for the arc
    const arcPoints = [];
    const segments = 30;

    for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const arcPoint = new THREE.Vector3()
            .copy(pointACartesian)
            .lerp(pointBCartesian, t)
            .normalize()
            .multiplyScalar(radius); // Ensure the point is on the globe's surface

        // Calculate the arc height using a smooth curve
        arcPoint.y += heightOffset * Math.sin(t * Math.PI); // Create an arc shape

        arcPoints.push(arcPoint.x, arcPoint.y, arcPoint.z);
    }

    const arcGeometry = new THREE.BufferGeometry();
    arcGeometry.setAttribute('position', new THREE.Float32BufferAttribute(arcPoints, 3));
    const arcMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
    const arc = new THREE.Line(arcGeometry, arcMaterial);

    // Add the arc as a child of the globe
    globe.add(arc); // Assuming "globe" is your globe mesh

    // Log arc creation
    //console.log('Arc created between points A and B');

    // Arc disappears after 1 second
    setTimeout(() => {
        globe.remove(arc); // Remove the arc from the globe
        //console.log('Arc removed');
    }, 1000);
}

document.addEventListener('touchstart', onTouchStart);
document.addEventListener('touchmove', onTouchMove);
document.addEventListener('touchend', onTouchEnd);

function onTouchStart(event) {
    mouseDown = true;
    previousMousePosition = { 
        x: event.touches[0].clientX, 
        y: event.touches[0].clientY 
    };
}

function onTouchMove(event) {
    if (!mouseDown) return;

    const deltaMove = {
        x: event.touches[0].clientX - previousMousePosition.x,
        y: event.touches[0].clientY - previousMousePosition.y
    };

    globe.rotation.y += deltaMove.x * 0.005;  // Adjust rotation speed
    globe.rotation.x += deltaMove.y * 0.005;  // Adjust rotation speed

    previousMousePosition = { 
        x: event.touches[0].clientX, 
        y: event.touches[0].clientY 
    };
}

function onTouchEnd() {
    mouseDown = false;
}


        function animate() {
            requestAnimationFrame(animate);
            
            // Update the globe and arcs
            if (globe) {
                globe.rotation.y += 0.005; // Example rotation speed, you can adjust or remove this
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
